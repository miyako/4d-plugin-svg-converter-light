/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : SVG Converter Light
 #	author : miyako
 #	2017/05/26
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

static cairo_status_t rsvg_cairo_write_func (void *data, const unsigned char *bytes, unsigned int len)
{
	if(len > 0)
	{
		C_BLOB *blob = (C_BLOB *)data;
		blob->addBytes(bytes, len);
	}
	
	return CAIRO_STATUS_SUCCESS;
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Convert Many

		case 1 :
			SVGL_Convert_array(pResult, pParams);
			break;

// --- Convert One

		case 2 :
			SVGL_Convert(pResult, pParams);
			break;

	}
}

#pragma mark -

// --------------------------------- Convert Many ---------------------------------


void SVGL_Convert_array(sLONG_PTR *pResult, PackagePtr pParams)
{
	PA_Variable Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_REAL Param5;
	C_LONGINT Param6;
	C_LONGINT returnValue;

	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);
	Param6.fromParamAtIndex(pParams, 6);

	Param1 = *((PA_Variable*) pParams[0]);
	
	switch (Param1.fType)
	{
		case eVK_ArrayPicture:
			break;
		case eVK_Undefined:
			PA_ClearVariable(&Param1);
			Param1 = PA_CreateVariable(eVK_ArrayPicture);
			break;
		default:
			break;
	}
	
	cairo_surface_t *surface = NULL;
	cairo_t *cr = NULL;
	
	CUTF8String type = CUTF8String((const uint8_t *)".svg", 4);
	
	if(Param1.fType == eVK_ArrayPicture){
		
		for(int i = 0; i <= Param1.uValue.fArray.fNbElements; ++i) {
			
			PA_Picture picture = PA_GetPictureInArray(Param1, i);
			
			unsigned int j;
			PA_ErrorCode err = eER_NoErr;
			
			j = 0;
			
			while (err == eER_NoErr){
				
				PA_Handle h = PA_NewHandle(0);
				PA_Unistring u = PA_GetPictureData(picture, ++j, h);
				err = PA_GetLastError();
				
				if(err == eER_NoErr)
				{
					C_TEXT t;
					t.setUTF16String(&u);
					CUTF8String uti;
					t.copyUTF8String(&uti);
					CUTF8String typestring;
					
					size_t pos, found;
					found = 0;
					
					for(pos = uti.find(';'); pos != CUTF8String::npos; pos = uti.find(';', found))
					{
						typestring = uti.substr(found, pos-found);
						found = pos + 1;
						
						if(!typestring.compare(type)){
							
							const uint8_t *p = (const uint8_t *)PA_LockHandle(h);
							
							if(p) {
								
								unsigned int svg_width, svg_height;
								
								svg_cairo_status_t status;
								svg_cairo_t *svgc;
								
								double dx = 0, dy = 0;
								
								double scale = 1;
								if(Param5.getDoubleValue())
									scale = Param5.getDoubleValue();
								
								int width = Param3.getIntValue();
								int height = Param4.getIntValue();
								
								status = svg_cairo_create (&svgc);
								
								if (!status) {
									
									status = svg_cairo_parse_buffer (svgc, (const char *)p, PA_GetHandleSize(h));
									
									if (!status) {
										
										svg_cairo_get_size (svgc, &svg_width, &svg_height);
										
										if (width <= 0 && height <= 0) {
											width = (svg_width * scale + 0.5);
											height = (svg_height * scale + 0.5);
										} else if (width <= 0) {
											scale = (double) height / (double) svg_height;
											width = (svg_width * scale + 0.5);
										} else if (height <= 0) {
											scale = (double) width / (double) svg_width;
											height = (svg_height * scale + 0.5);
										} else {
											scale = MIN ((double) width / (double) svg_width, (double) height / (double) svg_height);
											/* Center the resulting image */
											dx = (width - (int) (svg_width * scale + 0.5)) / 2;
											dy = (height - (int) (svg_height * scale + 0.5)) / 2;
										}
										
										surface = cairo_pdf_surface_create_for_stream (rsvg_cairo_write_func,
																																	 (void *)&Param2,
																																	 width,
																																	 height);
										
										cr = cairo_create (surface);
										
										cairo_translate (cr, dx, dy);
										cairo_scale (cr, scale, scale);
										
										returnValue.setIntValue(svg_cairo_render (svgc, cr));
										
										cairo_show_page (cr);
										
									}else{returnValue.setIntValue(status);}
									
									svg_cairo_destroy (svgc);
									
								}else{returnValue.setIntValue(status);}
							}else{returnValue.setIntValue(-2);}
							
						}
					}
				}
				PA_DisposeHandle(h);
			}
		}
		if(cr){
			cairo_destroy(cr);
			cairo_surface_destroy(surface);
		}
	}
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

// ---------------------------------- Convert One ---------------------------------

void SVGL_Convert(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_PICTURE Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_REAL Param5;
	C_LONGINT Param6;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);
	Param6.fromParamAtIndex(pParams, 6);

	CUTF8String type = CUTF8String((const uint8_t *)".svg", 4);
	
	const uint8_t *p = Param1.getBytesPtr(&type);
	
	if(p) {
		
		unsigned int svg_width, svg_height;
		
		svg_cairo_status_t status;
		cairo_t *cr;
		svg_cairo_t *svgc;
		cairo_surface_t *surface;
		double dx = 0, dy = 0;
		
		double scale = 1;
		if(Param5.getDoubleValue())
			scale = Param5.getDoubleValue();
		
		int width = Param3.getIntValue();
		int height = Param4.getIntValue();
		
		status = svg_cairo_create (&svgc);
		
		if (!status) {
			
			status = svg_cairo_parse_buffer (svgc, (const char *)p, Param1.getBytesLength(&type));
			
			if (!status) {
				
				svg_cairo_get_size (svgc, &svg_width, &svg_height);
				
				if (width <= 0 && height <= 0) {
					width = (svg_width * scale + 0.5);
					height = (svg_height * scale + 0.5);
				} else if (width <= 0) {
					scale = (double) height / (double) svg_height;
					width = (svg_width * scale + 0.5);
				} else if (height <= 0) {
					scale = (double) width / (double) svg_width;
					height = (svg_height * scale + 0.5);
				} else {
					scale = MIN ((double) width / (double) svg_width, (double) height / (double) svg_height);
					/* Center the resulting image */
					dx = (width - (int) (svg_width * scale + 0.5)) / 2;
					dy = (height - (int) (svg_height * scale + 0.5)) / 2;
				}
				
				surface = cairo_pdf_surface_create_for_stream (rsvg_cairo_write_func,
																											 (void *)&Param2,
																											 width,
																											 height);
				
				cr = cairo_create (surface);
				
				cairo_translate (cr, dx, dy);
				cairo_scale (cr, scale, scale);
				
				returnValue.setIntValue(svg_cairo_render (svgc, cr));
				
				cairo_show_page (cr);
				cairo_destroy (cr);
				cairo_surface_destroy (surface);
				
			}else{returnValue.setIntValue(status);}
			
			svg_cairo_destroy (svgc);
			
		}else{returnValue.setIntValue(status);}
	}else{returnValue.setIntValue(-2);}
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}
